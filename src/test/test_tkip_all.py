#/usr/bin/python
# -*- coding: utf-8 -*-
'''
Testa le operazioni del modulo rc4
OSS: nei test del crc-32 il pack viene fatto in modi diversi (vedi 'testCrc32_2' e 'testCrc32_3' --> struct.unpack) 
'''
import sys
sys.path.append('/media/DATA/06-WorkSpace/netsec_wp/src/crypto')
import wep
import unittest
import struct
import binascii
import array
from tkip import TKIP_Decryptor_Low,TkipDecryptor
from tkip_mic_utility import TkipMicGenerator
from scapy.all import *

class TestTKIP(unittest.TestCase):
	'''
	Casi di test per le operazioni definite nel modulo TKIP
	'''
	def test_TKIP_decryption_01_a(self):
		'''
		testo la classe TkipMicGenerator
		test a pagina 1134 e 1135 della rfc 802.11-2007
		ATTENZIONE: le mpdu contengono gli header che non devono essere xorati
		'''
		sa = struct.pack('6B',0x02,0x03,0x04,0x05,0x06,0x07)
		da = struct.pack('6B',0x02,0x03,0x04,0x05,0x06,0x08)
		priority = struct.pack('1B',0x00)
		tk = struct.pack('32B',0x12,0x34,0x56,0x78,0x90,0x12,0x34,0x56,0x78,0x90,0x12,0x34,0x56,0x78,0x90,0x12,0x34,0x56,0x78,0x90,0x12,0x34,0x56,0x78,0x90,0x12,0x34,0x56,0x78,0x90,0x12,0x34)
		iv = struct.pack('8B',0x00,0x20,0x01,0x20,0x00,0x00,0x00,0x00)
		phase1 = struct.pack('10B',0xbb,0x58,0x07,0x1f,0x9e,0x93,0xb4,0x38,0x25,0x4b)
		phase2 = struct.pack('16B',0x00,0x20,0x01,0x4c,0xfe,0x67,0xbe,0xd2,0x7c,0x86,0x7b,0x1b,0xf8,0x02,0x8b,0x1c)
		#mpdu comprende anche l'header 802.11 che è da togliere [32 byte]
		mpdu_plaintext = struct.pack('132B',0x08,0x42,0x2c,0x00,0x02,0x03,0x04,0x05,0x06,0x08,0x02,0x03,0x04,0x05,0x06,0x07,0x02,0x03,0x04,0x05,0x06,0x07,0xd0,0x02,0x00,0x20,0x01,0x20,0x00,0x00,0x00,0x00,0xaa,0xaa,0x03,0x00,0x00,0x00,0x08,0x00,0x45,0x00,0x00,0x54,0x00,0x00,0x40,0x00,0x40,0x01,0xa5,0x55,0xc0,0xa8,0x0a,0x02,0xc0,0xa8,0x0a,0x01,0x08,0x00,0x3a,0xb0,0x00,0x00,0x00,0x00,0xcd,0x4c,0x05,0x00,0x00,0x00,0x00,0x00,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x68,0x81,0xa3,0xf3,0xd6,0x48,0xd0,0x3c)
		plaintext = mpdu_plaintext[32:]
		ciphertext_mpdu = struct.pack('136B',0x08,0x42,0x2c,0x00,0x02,0x03,0x04,0x05,0x06,0x08,0x02,0x03,0x04,0x05,0x06,0x07,0x02,0x03,0x04,0x05,0x06,0x07,0xd0,0x02,0x00,0x20,0x01,0x20,0x00,0x00,0x00,0x00,0xc0,0x0e,0x14,0xfc,0xe7,0xcf,0xab,0xc7,0x75,0x47,0xe6,0x66,0xe5,0x7c,0x0d,0xac,0x70,0x4a,0x1e,0x35,0x8a,0x88,0xc1,0x1c,0x8e,0x2e,0x28,0x2e,0x38,0x01,0x02,0x7a,0x46,0x56,0x05,0x5e,0xe9,0x3e,0x9c,0x25,0x47,0x02,0xe9,0x73,0x58,0x05,0xdd,0xb5,0x76,0x9b,0xa7,0x3f,0x1e,0xbb,0x56,0xe8,0x44,0xef,0x91,0x22,0x85,0xd3,0xdd,0x6e,0x54,0x1e,0x82,0x38,0x73,0x55,0x8a,0xdb,0xa0,0x79,0x06,0x8a,0xbd,0x7f,0x7f,0x50,0x95,0x96,0x75,0xac,0xc4,0xb4,0xde,0x9a,0xa9,0x9c,0x05,0xf2,0x89,0xa7,0xc5,0x2f,0xee,0x5b,0xfc,0x14,0xf6,0xf8,0xe5,0xf8)
		ciphertext = ciphertext_mpdu[32:]
		micKey = tk[16:24]
		
		paddedMSDU =  da + sa + priority + 3*chr(0) + plaintext[:-8]
		micResult = plaintext[-8:]
		micGen = TkipMicGenerator(paddedMSDU,micKey)
		myMic = micGen.getMic()
		self.assertEqual(micResult,myMic)
		# il mic calcolato sul plaintext è corretto

	

	def test_TKIP_decryption_01_b(self):
		'''
		testo la classe TKIP_Decryptor_Low
		test a pagina 1134 e 1135 della rfc 802.11-2007
		ATTENZIONE: le mpdu contengono gli header che non devono essere xorati
		'''
		sa = struct.pack('6B',0x02,0x03,0x04,0x05,0x06,0x07)
		da = struct.pack('6B',0x02,0x03,0x04,0x05,0x06,0x08)
		priority = struct.pack('1B',0x00)
		tk = struct.pack('32B',0x12,0x34,0x56,0x78,0x90,0x12,0x34,0x56,0x78,0x90,0x12,0x34,0x56,0x78,0x90,0x12,0x34,0x56,0x78,0x90,0x12,0x34,0x56,0x78,0x90,0x12,0x34,0x56,0x78,0x90,0x12,0x34)
		iv = struct.pack('8B',0x00,0x20,0x01,0x20,0x00,0x00,0x00,0x00)
		phase1 = struct.pack('10B',0xbb,0x58,0x07,0x1f,0x9e,0x93,0xb4,0x38,0x25,0x4b)
		phase2 = struct.pack('16B',0x00,0x20,0x01,0x4c,0xfe,0x67,0xbe,0xd2,0x7c,0x86,0x7b,0x1b,0xf8,0x02,0x8b,0x1c)
		#mpdu comprende anche l'header 802.11 che è da togliere [32 byte]
		mpdu_plaintext = struct.pack('132B',0x08,0x42,0x2c,0x00,0x02,0x03,0x04,0x05,0x06,0x08,0x02,0x03,0x04,0x05,0x06,0x07,0x02,0x03,0x04,0x05,0x06,0x07,0xd0,0x02,0x00,0x20,0x01,0x20,0x00,0x00,0x00,0x00,0xaa,0xaa,0x03,0x00,0x00,0x00,0x08,0x00,0x45,0x00,0x00,0x54,0x00,0x00,0x40,0x00,0x40,0x01,0xa5,0x55,0xc0,0xa8,0x0a,0x02,0xc0,0xa8,0x0a,0x01,0x08,0x00,0x3a,0xb0,0x00,0x00,0x00,0x00,0xcd,0x4c,0x05,0x00,0x00,0x00,0x00,0x00,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x68,0x81,0xa3,0xf3,0xd6,0x48,0xd0,0x3c)
		plaintext = mpdu_plaintext[32:]
		ciphertext_mpdu = struct.pack('136B',0x08,0x42,0x2c,0x00,0x02,0x03,0x04,0x05,0x06,0x08,0x02,0x03,0x04,0x05,0x06,0x07,0x02,0x03,0x04,0x05,0x06,0x07,0xd0,0x02,0x00,0x20,0x01,0x20,0x00,0x00,0x00,0x00,0xc0,0x0e,0x14,0xfc,0xe7,0xcf,0xab,0xc7,0x75,0x47,0xe6,0x66,0xe5,0x7c,0x0d,0xac,0x70,0x4a,0x1e,0x35,0x8a,0x88,0xc1,0x1c,0x8e,0x2e,0x28,0x2e,0x38,0x01,0x02,0x7a,0x46,0x56,0x05,0x5e,0xe9,0x3e,0x9c,0x25,0x47,0x02,0xe9,0x73,0x58,0x05,0xdd,0xb5,0x76,0x9b,0xa7,0x3f,0x1e,0xbb,0x56,0xe8,0x44,0xef,0x91,0x22,0x85,0xd3,0xdd,0x6e,0x54,0x1e,0x82,0x38,0x73,0x55,0x8a,0xdb,0xa0,0x79,0x06,0x8a,0xbd,0x7f,0x7f,0x50,0x95,0x96,0x75,0xac,0xc4,0xb4,0xde,0x9a,0xa9,0x9c,0x05,0xf2,0x89,0xa7,0xc5,0x2f,0xee,0x5b,0xfc,0x14,0xf6,0xf8,0xe5,0xf8)
		ciphertext = ciphertext_mpdu[32:]
		micKey = tk[16:24]
		
		micResult = plaintext[-8:]

		decryptor = TKIP_Decryptor_Low(ciphertext,sa,iv,tk[:16],micKey,da,priority)
		plaintextTuple = decryptor.decryptPayload()
		self.assertEqual(plaintext,struct.pack(str(len(plaintextTuple))+'B',*plaintextTuple)[:-4])
		# il mic calcolato con il decryptor low è corretto



	def test_TKIP_decryption_01_c(self):
		'''
		testo la classe TkipDecryptor
		test a pagina 1134 e 1135 della rfc 802.11-2007
		ATTENZIONE: le mpdu contengono gli header che non devono essere xorati
		'''
		sa = struct.pack('6B',0x02,0x03,0x04,0x05,0x06,0x07)
		da = struct.pack('6B',0x02,0x03,0x04,0x05,0x06,0x08)
		priority = struct.pack('1B',0x00)
		tk = struct.pack('32B',0x12,0x34,0x56,0x78,0x90,0x12,0x34,0x56,0x78,0x90,0x12,0x34,0x56,0x78,0x90,0x12,0x34,0x56,0x78,0x90,0x12,0x34,0x56,0x78,0x90,0x12,0x34,0x56,0x78,0x90,0x12,0x34)
		iv = struct.pack('8B',0x00,0x20,0x01,0x20,0x00,0x00,0x00,0x00)
		phase1 = struct.pack('10B',0xbb,0x58,0x07,0x1f,0x9e,0x93,0xb4,0x38,0x25,0x4b)
		phase2 = struct.pack('16B',0x00,0x20,0x01,0x4c,0xfe,0x67,0xbe,0xd2,0x7c,0x86,0x7b,0x1b,0xf8,0x02,0x8b,0x1c)
		#mpdu comprende anche l'header 802.11 che è da togliere [32 byte]
		mpdu_plaintext = struct.pack('132B',0x08,0x42,0x2c,0x00,0x02,0x03,0x04,0x05,0x06,0x08,0x02,0x03,0x04,0x05,0x06,0x07,0x02,0x03,0x04,0x05,0x06,0x07,0xd0,0x02,0x00,0x20,0x01,0x20,0x00,0x00,0x00,0x00,0xaa,0xaa,0x03,0x00,0x00,0x00,0x08,0x00,0x45,0x00,0x00,0x54,0x00,0x00,0x40,0x00,0x40,0x01,0xa5,0x55,0xc0,0xa8,0x0a,0x02,0xc0,0xa8,0x0a,0x01,0x08,0x00,0x3a,0xb0,0x00,0x00,0x00,0x00,0xcd,0x4c,0x05,0x00,0x00,0x00,0x00,0x00,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x68,0x81,0xa3,0xf3,0xd6,0x48,0xd0,0x3c)
		expecetdPlaintext = mpdu_plaintext[32:]
		ciphertext_mpdu = struct.pack('136B',0x08,0x42,0x2c,0x00,0x02,0x03,0x04,0x05,0x06,0x08,0x02,0x03,0x04,0x05,0x06,0x07,0x02,0x03,0x04,0x05,0x06,0x07,0xd0,0x02,0x00,0x20,0x01,0x20,0x00,0x00,0x00,0x00,0xc0,0x0e,0x14,0xfc,0xe7,0xcf,0xab,0xc7,0x75,0x47,0xe6,0x66,0xe5,0x7c,0x0d,0xac,0x70,0x4a,0x1e,0x35,0x8a,0x88,0xc1,0x1c,0x8e,0x2e,0x28,0x2e,0x38,0x01,0x02,0x7a,0x46,0x56,0x05,0x5e,0xe9,0x3e,0x9c,0x25,0x47,0x02,0xe9,0x73,0x58,0x05,0xdd,0xb5,0x76,0x9b,0xa7,0x3f,0x1e,0xbb,0x56,0xe8,0x44,0xef,0x91,0x22,0x85,0xd3,0xdd,0x6e,0x54,0x1e,0x82,0x38,0x73,0x55,0x8a,0xdb,0xa0,0x79,0x06,0x8a,0xbd,0x7f,0x7f,0x50,0x95,0x96,0x75,0xac,0xc4,0xb4,0xde,0x9a,0xa9,0x9c,0x05,0xf2,0x89,0xa7,0xc5,0x2f,0xee,0x5b,0xfc,0x14,0xf6,0xf8,0xe5,0xf8)
		
		#creo il pacchetto		
		scapyPacket = Dot11(ciphertext_mpdu)
		#scapyPacket.show()
		micKey = tk[16:24]
		
		decryptor = TkipDecryptor(scapyPacket,tk[:16],micKey)
		plaintextTuple = decryptor.getDecryptedPacket()
		plaintextString = struct.pack(str(len(plaintextTuple))+'B',*plaintextTuple)
		self.assertEqual(expecetdPlaintext,plaintextString[:-4])
		# il mic calcolato con il decryptor che usa i pacchetti di scapy è corretto



	def test_TKIP_decryption_02(self):
		'''
		Test 2 from Parag 2002-12-16
		'''
		# dati iniziali
		da =struct.pack('6B',0xaa,0xaa,0xaa,0xaa,0xaa,0xaa)
		sa = struct.pack('6B',0xbb,0xbb,0xbb,0xbb,0xbb,0xbb)
		priority = struct.pack('1B',0x03)
		payload = struct.pack('<IIIIIIIIIII',0xdeaf0005L, 0xdeaf0006L, 0xdeaf0007L, 0xdeaf0008L, 0xdeaf0009L, 0xdeaf000aL, 0xdeaf000bL, 0xdeaf000cL, 0xdeaf000dL, 0xdeaf000eL, 0x00ccdd00L)
		payload = payload[:-1] # trim off last octet

		# padded msdu
		paddedMSDU = da+sa+priority+3*chr(0)+payload

		# key		
		k0 = 0x01234567L
        	k1 = 0x89abcdefL
        	key = struct.pack('<II', k0, k1 )

		# mic        	
		v0 = 0xe597b391L
		v1 = 0xb8c4a7b7L
		micResultParag = struct.pack('<II', v0, v1) # pack little-endian dwords into 8 octets

		#calcolo il mic
		micGen = TkipMicGenerator(paddedMSDU,key)
		myMic = micGen.getMic()
		self.assertEqual(micResultParag,myMic)



	def test_TKIP_decryption_03(self):	
		'''
		Test 1 from Adrian 2002-12-12
		'''
		k0 = 0x00000000L      # assume is a 'dword'
		k1 = 0x00000000L
		key = struct.pack('<II', k0, k1 ) # pack two integers into string little-endian
		da  = struct.pack('6B',0x16,0x15,0x14,0x13,0x12,0x11)
		sa  = struct.pack('6B',0x26,0x25,0x24,0x23,0x22,0x21)
		priority = chr(2)
		payload = struct.pack('13B',0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c)
		v0 = 0x85a3fe4cL
		v1 = 0x20f4105fL
		micResultAdrian = struct.pack('<II', v0, v1) # pack little-endian dwords into 8 octets

		paddedMSDU = da + sa + priority + 3*chr(0) + payload
		#calcolo il mic
		micGen = TkipMicGenerator(paddedMSDU,key)
		myMic = micGen.getMic()
		self.assertEqual(myMic,micResultAdrian)



if __name__ == '__main__':
	suite = unittest.TestLoader().loadTestsFromTestCase(TestTKIP)
	unittest.TextTestRunner(verbosity=2).run(suite)

